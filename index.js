import express from "express";    
import { Agent, setGlobalDispatcher } from "undici";    
    
// ‰ºòÂåñËøûÊé•Ê±†ÈÖçÁΩÆ  
const agent = new Agent({    
  connections: 30,  // ‰ªé100ÈôçÂà∞30  
  pipelining: 1,    
  keepAliveTimeout: 30000,  // ‰ªé60ÁßíÈôçÂà∞30Áßí  
  keepAliveMaxTimeout: 30000    
});    
    
setGlobalDispatcher(agent);    
    
const app = express();    
const PORT = process.env.PORT || 3000;    
const API_BASE_URL = 'http://YOUR_DOMAIN:4000';    
  
// Ê∑ªÂä†URLÁºìÂ≠ò  
const urlCache = new Map();  
const CACHE_TTL = 10 * 60 * 1000; // 10ÂàÜÈíü  
  
// ÁºìÂ≠òÊ∏ÖÁêÜÂáΩÊï∞  
function cleanCache() {  
  const now = Date.now();  
  for (const [key, value] of urlCache.entries()) {  
    if (now - value.timestamp > CACHE_TTL) {  
      urlCache.delete(key);  
    }  
  }  
}  
  
// ÊØè5ÂàÜÈíüÊ∏ÖÁêÜ‰∏ÄÊ¨°ËøáÊúüÁºìÂ≠ò  
setInterval(cleanCache, 5 * 60 * 1000);  
    
app.use(express.json());    
    
app.options('*', (req, res) => {    
  res.set({    
    'Access-Control-Allow-Origin': '*',    
    'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',    
    'Access-Control-Allow-Headers': 'Content-Type, Range',    
    'Access-Control-Expose-Headers': 'Content-Length, Content-Range, Accept-Ranges'    
  });    
  res.sendStatus(204);    
});    
    
// ÂÅ•Â∫∑Ê£ÄÊü•Á´ØÁÇπ    
app.get('/health', (req, res) => {    
  res.status(200).json({   
    status: 'ok',   
    timestamp: Date.now(),  
    cacheSize: urlCache.size  
  });    
});    
    
// üî• ËßÜÈ¢ë‰ª£ÁêÜË∑ØÁî±(‰ª£ÁêÜÊ®°Âºè,‰∏çÊòØÈáçÂÆöÂêë)    
app.get('/r/:fileId', async (req, res) => {    
  let fileId = req.params.fileId;    
  fileId = fileId.replace(/\.(m3u8|mkv|mp4|avi|flv|webm|mov)$/i, '');    
    
  // ÂàõÂª∫AbortControllerÁî®‰∫éÊ∏ÖÁêÜ  
  const abortController = new AbortController();  
  let reader = null;  
    
  // ÁõëÂê¨ÂÆ¢Êà∑Á´ØÊñ≠ÂºÄËøûÊé•  
  req.on('close', () => {  
    console.log(`üîå [PROXY] ÂÆ¢Êà∑Á´ØÊñ≠ÂºÄËøûÊé•: ${fileId}`);  
    abortController.abort(); // ÂèñÊ∂àÊâÄÊúâ‰∏äÊ∏∏ËØ∑Ê±Ç  
    if (reader) {  
      reader.cancel().catch(() => {}); // ÂèñÊ∂àÊµÅËØªÂèñ  
    }  
  });  
      
  try {    
    // 1. Ê£ÄÊü•ÁºìÂ≠ò  
    const cached = urlCache.get(fileId);  
    let playUrl;  
      
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {  
      console.log(`üíæ [CACHE HIT] ${fileId}`);  
      playUrl = cached.url;  
    } else {  
      // Ëé∑ÂèñÁúüÂÆûURL  
      const playResponse = await fetch(`http://YOUR_DOMAIN:4567/play?id=${fileId}`, {    
        headers: {    
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'    
        },    
        signal: abortController.signal,  
        dispatcher: agent  
      });    
          
      if (!playResponse.ok) {    
        console.error(`‚ùå [PROXY] Play APIËøîÂõûÈîôËØØ: ${playResponse.status}`);    
        return res.status(404).send('File not found');    
      }    
          
      const playData = await playResponse.json();    
          
      if (!playData.url) {    
        console.error(`‚ùå [PROXY] Play APIÊú™ËøîÂõûURL: ${fileId}`);    
        return res.status(404).send('URL not found');    
      }    
        
      playUrl = playData.url;  
      // ÁºìÂ≠òURL  
      urlCache.set(fileId, { url: playUrl, timestamp: Date.now() });  
        
      // ÈôêÂà∂ÁºìÂ≠òÂ§ßÂ∞è  
      if (urlCache.size > 1000) {  
        cleanCache();  
      }  
    }  
        
    console.log(`üîó [PROXY] ${fileId} -> ${playUrl.substring(0, 100)}...`);    
        
    // 2. ‰ª£ÁêÜËßÜÈ¢ëÊµÅ  
    const videoResponse = await fetch(playUrl, {    
      headers: {    
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',    
        'Range': req.headers.range || 'bytes=0-',    
      },  
      signal: abortController.signal,  
      dispatcher: agent  
    });    
        
    if (!videoResponse.ok) {    
      console.error(`‚ùå [PROXY] ËßÜÈ¢ëËé∑ÂèñÂ§±Ë¥•: ${videoResponse.status}`);    
      return res.status(videoResponse.status).send('Video fetch failed');    
    }    
        
    // 3. ËÆæÁΩÆCORSÂ§¥ÂíåÂÖ∂‰ªñÂìçÂ∫îÂ§¥    
    res.set({    
      'Access-Control-Allow-Origin': '*',    
      'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',    
      'Access-Control-Allow-Headers': 'Range, Content-Type',    
      'Access-Control-Expose-Headers': 'Content-Length, Content-Range, Accept-Ranges',    
      'Content-Type': videoResponse.headers.get('Content-Type') || 'video/mp4',    
      'Content-Length': videoResponse.headers.get('Content-Length'),    
      'Content-Range': videoResponse.headers.get('Content-Range'),    
      'Accept-Ranges': 'bytes'    
    });    
        
    // 4. ÊµÅÂºè‰º†ËæìÊï∞ÊçÆ  
    if (!videoResponse.body) {    
      return res.status(500).send('No video stream');    
    }    
      
    reader = videoResponse.body.getReader();    
        
    try {    
      while (true) {    
        const { done, value } = await reader.read();    
            
        if (done) {    
          res.end();    
          break;    
        }    
            
        // ‰ΩøÁî®ËÉåÂéãÊéßÂà∂    
        if (!res.write(value)) {    
          await new Promise(resolve => res.once('drain', resolve));    
        }    
      }    
    } catch (error) {    
      // ÂøΩÁï•ÂÆ¢Êà∑Á´ØÊñ≠ÂºÄÂØºËá¥ÁöÑÈîôËØØ  
      if (error.name !== 'AbortError') {  
        console.error(`‚ùå [PROXY STREAM ERROR] ${fileId}:`, error.message);    
      }  
      if (!res.headersSent) {    
        res.status(500).send('Stream error');    
      }    
    } finally {    
      if (reader) {  
        reader.releaseLock();    
      }  
    }    
        
  } catch (error) {    
    // ÂøΩÁï•ÂÆ¢Êà∑Á´ØÊñ≠ÂºÄÂØºËá¥ÁöÑÈîôËØØ  
    if (error.name !== 'AbortError') {  
      console.error(`‚ùå [PROXY ERROR] ${fileId}:`, error.message);    
    }  
    if (!res.headersSent) {    
      return res.status(500).send('Internal server error');    
    }    
  }    
});  
    
// ‰∏ªAPIÁ´ØÁÇπ    
app.get('/', async (req, res) => {    
  const requestStartTime = Date.now();    
  const params = req.query;    
  const ac = params.ac;    
  const wd = params.wd;    
  const ids = params.ids;    
    
  const corsHeaders = {    
    'Access-Control-Allow-Origin': '*',    
    'Access-Control-Allow-Methods': 'GET, OPTIONS',    
    'Access-Control-Allow-Headers': 'Content-Type',    
    'Content-Type': 'application/json; charset=utf-8'    
  };    
    
  try {    
    const upstreamUrl = new URL('http://YOUR_DOMAIN:4567/vod1/');    
    Object.keys(params).forEach(key => upstreamUrl.searchParams.append(key, params[key]));    
    
    const response = await fetch(upstreamUrl.toString(), {    
      headers: { 'User-Agent': 'Mozilla/5.0' },    
      signal: AbortSignal.timeout(60000),  
      dispatcher: agent  
    });    
    
    if (!response.ok) {    
      return res.status(response.status).set(corsHeaders).send(`‰∏äÊ∏∏APIÈîôËØØ: ${response.statusText}`);    
    }    
    
    const data = await response.json();    
    const needsTransform = ac === 'videolist' && (wd || ids);    
    
    console.log(`üìù [DEBUG] ac=${ac}, wd=${wd}, ids=${ids}, needsTransform=${needsTransform}`);    
    console.log(`üì¶ [DEBUG] ‰∏äÊ∏∏ËøîÂõûÊï∞ÊçÆ: list.length=${data.list?.length}`);    
    
    let responseData;    
    if (needsTransform && data.list && data.list.length > 0) {    
      console.log(`üîÑ [DEBUG] ÂºÄÂßãÊâßË°å transformResponse`);    
      responseData = await transformResponse(data);    
    } else {    
      console.log(`‚ö†Ô∏è [DEBUG] Ë∑≥Ëøá transformResponse,Áõ¥Êé•ËøîÂõûÂéüÂßãÊï∞ÊçÆ`);    
      responseData = data;    
    }    
    
    const userAgent = req.headers['user-agent'] || '';  
    const isBrowser = userAgent.includes('Mozilla');  
              
    let responseText = JSON.stringify(responseData);  
    if (isBrowser) {  
      responseText = replaceAllDoubanImages(responseText);  
    }    
    
    res.set(corsHeaders).send(responseText);  
    
    const totalDuration = Date.now() - requestStartTime;    
    console.log(`‚è±Ô∏è [LUNA SEARCH TIME] ${totalDuration}ms (${(totalDuration/1000).toFixed(2)}s) - LunaTVË∂ÖÊó∂ÈôêÂà∂: 20s`);    
    if (totalDuration > 20000) {    
      console.log(`‚ö†Ô∏è Ë≠¶Âëä: Ë∂ÖËøáLunaTVÁöÑ20ÁßíË∂ÖÊó∂!`);    
    }    
    
  } catch (error) {    
    console.error('APIÈîôËØØ:', error);    
    return res.status(500).set(corsHeaders).send(`ÊúçÂä°Âô®ÈîôËØØ: ${error.message}`);    
  }    
});   
  
function replaceAllDoubanImages(text) {              
  if (text.includes('image-proxy?url=')) {              
    return text;              
  }              
              
  return text.replace(              
    /(https?:\/\/)(img\d+\.doubanio\.com)(\/[^\s"']*)?/g,              
    (match, protocol, domain, path) => {              
      const originalUrl = match;              
      return `http://YOUR_DOMAIN:3000/api/image-proxy?url=${encodeURIComponent(originalUrl)}`;              
    }              
  );              
}  
  
async function transformResponse(data) {    
  const results = await Promise.allSettled(data.list.map(async (item) => {    
    try {    
      console.log(`[PROCESSING] ${item.vod_name} (${item.vod_id})`);    
    
      const detailUrl = new URL('http://YOUR_DOMAIN:4567/vod1/');    
      detailUrl.searchParams.append('ac', 'videolist');    
      detailUrl.searchParams.append('ids', item.vod_id);
        
      const detailStartTime = Date.now(); 
    
      const detailResponse = await fetch(detailUrl.toString(), {    
        headers: { 'User-Agent': 'Mozilla/5.0' },    
        signal: AbortSignal.timeout(8000),  
        dispatcher: agent  
      });    
         // Ê∑ªÂä†ËÆ°Êó∂ - ÁªìÊùüÂπ∂ÊâìÂç∞  
      const detailTime = Date.now() - detailStartTime;  
      console.log(`‚è±Ô∏è [FETCH DETAIL] ${item.vod_id} took ${detailTime}ms`);  
 
      if (!detailResponse.ok) {    
        throw new Error(`ËØ¶ÊÉÖAPIÈîôËØØ: ${detailResponse.status}`);    
      }    
    
      const detailData = await detailResponse.json();    
      if (!detailData.list || detailData.list.length === 0) {    
        throw new Error(`ËØ¶ÊÉÖÊï∞ÊçÆ‰∏∫Á©∫: ${item.vod_id}`);    
      }    
    
      const detailItem = detailData.list[0];    
      if (!detailItem.vod_play_url) {    
        throw new Error(`Êó†Êí≠ÊîæÂú∞ÂùÄ: ${item.vod_id}`);    
      }    
    
      const playInfo = await transformPlayUrl(detailItem);    
      const transformed = { ...item };    
      transformed.vod_play_from = detailItem.vod_play_from || 'ÈªòËÆ§';    
      transformed.vod_play_url = playInfo.url;    
      transformed.vod_play_server = 'no';    
      transformed.vod_play_note = '';    
    
      if (playInfo.subs && playInfo.subs.length > 0) {    
        transformed.vod_play_subs = playInfo.subs;    
      }    
    
      if (!transformed.vod_play_url || transformed.vod_play_url === '') {    
        throw new Error(`Êí≠ÊîæÂú∞ÂùÄËΩ¨Êç¢Â§±Ë¥•: ${item.vod_id}`);    
      }    
    
      return transformed;    
    } catch (error) {    
      console.error(`Â§ÑÁêÜÂ§±Ë¥•: ${item.vod_name}`, error);    
      return null;    
    }    
  }));    
    
  const transformedList = results    
    .filter(result => result.status === 'fulfilled' && result.value !== null)    
    .map(result => result.value);    
    
  console.log(`üìä [TRANSFORM] ËΩ¨Êç¢ÁªìÊûú: ${transformedList.length}/${results.length} ÊàêÂäü`);    
    
  return {    
    code: 1,    
    msg: 'Êï∞ÊçÆÂàóË°®',    
    page: data.page || 1,    
    pagecount: data.pagecount || 1,    
    limit: data.limit || '20',    
    total: transformedList.length,    
    list: transformedList    
  };    
}    
    
function extractContent(content) {    
  if (!content) return '';    
  const parts = content.split(';\n');    
  if (parts.length > 1) {    
    return parts.slice(1).join('\n').trim();    
  }    
  return content;    
}    
    
async function transformPlayUrl(item) {    
  const playUrl = item.vod_play_url;    
  if (!playUrl) return { url: '', subs: [] };    
    
  let directoryPath = '';    
  if (item.vod_content) {    
  const pathMatch = item.vod_content.match(/È¶ôËïâ:(.+?);/);    
    if (pathMatch) {    
      directoryPath = pathMatch[1];    
    }    
  }    
    
  const isTVShow = directoryPath.includes('/ÁîµËßÜËäÇÁõÆ/');    
  const playUrlGroups = playUrl.split('$$$');    
  const allEpisodes = [];    
    
  const startTime = Date.now();    
    
  // üî• ÂÖ≥ÈîÆ‰ºòÂåñ:Áõ¥Êé•‰ªévod_play_urlÊèêÂèñfileId,‰∏çË∞ÉÁî®play API    
  for (const urlGroup of playUrlGroups) {    
    const episodes = urlGroup.split('#');    
    for (const episode of episodes) {    
      const parts = episode.split('$');    
      if (parts.length !== 2) continue;    
    
      let [title, fileId] = parts; // fileIdÂ∞±ÊòØ519616-1ËøôÊ†∑ÁöÑÊ†ºÂºè    
    
      if (isTVShow) {    
        const episodeMatch = title.match(/S(\d+)E(\d+)/i);    
        const sizeMatch = title.match(/\(([^)]+?(?:GB|MB|KB))\)/i);    
        if (episodeMatch) {    
          const season = episodeMatch[1].padStart(2, '0');    
          const ep = episodeMatch[2].padStart(2, '0');    
          const size = sizeMatch ? sizeMatch[1] : '';    
          title = size ? `S${season}E${ep}(${size})` : `S${season}E${ep}`;    
        }    
      } else {    
        const sizeMatch = title.match(/\(([^)]+?(?:GB|MB|KB))\)/i);    
        const size = sizeMatch ? sizeMatch[1] : '';    
        title = size ? `HDÈ´òÊ∏Ö(${size})` : 'HDÈ´òÊ∏Ö';    
      }    
    
      // Áõ¥Êé•ÊûÑÂª∫Áü≠ÈìæÊé•,ÂÅáË£ÖÊ∑ªÂä†.mkvÂêéÁºÄ    
      const shortUrl = `${API_BASE_URL}/r/${fileId}.mkv`;    
      allEpisodes.push(`${title}$${shortUrl}`);    
    }    
  }    
    
  const endTime = Date.now();    
  const totalTime = endTime - startTime;    
  console.log(`[EPISODES RESOLVED] ${allEpisodes.length} episodes in ${totalTime}ms`);    
    
  return {    
    url: allEpisodes.join('#'),    
    subs: [] // ÊêúÁ¥¢Êó∂‰∏çËøîÂõûÂ≠óÂπï    
  };    
}    
    
app.listen(PORT, () => {    
  console.log(`Server is running on http://localhost:${PORT}`);    
});
